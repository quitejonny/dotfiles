test-foswiki() {
    IS_VERBOSE=false
    IS_DOCKER_IMAGE_PULLED=true
    CLEAR="clear"
    IS_WATCHED=false
    DOCKER_IMAGE="quay.io/modellaachen/perl-test:latest"

    usage() {
        printf -v text "%s" \
            "test-fosiki [OPTION...]\n" \
            "    -c, --no-clear     does not clear shell before tests are run\n" \
            "    -i, --image        use a different docker image\n" \
            "    -p, --no-pull      does not pull docker image\n" \
            "    -v, --verbose      shows failed tests only\n" \
            "    -w, --watch        watches backend tests\n" \
            "        --create       creates a new folder and testrunner in \$repo\n"
        printf "$text"
    }

    create_infrastructure() {
        TEST_DIR=backend-tests
        SPEC_DIR=$TEST_DIR/Spec
        mkdir -p $SPEC_DIR

        cat > $TEST_DIR/test.pl << EOL
package Test;

use strict;
use warnings;

use File::Basename;
use Cwd qw( getcwd abs_path );

use utf8;
use Test::Spec;
use Jasmine::Spy;


sub getSpecs {
    my (\$pattern) = @_;

    my \$cwd = getcwd();
    chdir dirname(__FILE__);
    my @specs = map { abs_path(\$_) } glob(\$pattern);
    chdir \$cwd;

    return @specs;
}

my @specs = getSpecs("Spec/**Spec.pm Spec/**Spec.pl");

for my \$spec (@specs) {
    print("\$spec\n");
    spec_helper \$spec;
}

runtests unless caller;
EOL

        cat > $SPEC_DIR/ExampleSpec.pm << EOL
describe "the example spec" => sub {
    it "verifies the calculation" => sub {
        is(5+5, 10);
    };
};
EOL

        exit
    }

    OPTS=`getopt -o ci:pvwh --long no-clear,image:,no-pull,verbose,watch,create,help -- "$@"`
    if [ $? != 0 ] ; then echo "Failed parsing options." >&2 ; exit 1 ; fi

    eval set -- "$OPTS"

    while true; do
        case "$1" in
            -c | --no-clear )
                CLEAR=""
                shift ;;
            -i | --image )
                DOCKER_IMAGE=$2
                shift 2 ;;
            -p | --no-pull )
                IS_DOCKER_IMAGE_PULLED=false
                shift ;;
            -w | --watch )
                IS_WATCHED=true
                shift ;;
            -v | --verbose )
                IS_VERBOSE=true
                shift ;;
            --create )
                create_infrastructure;
                shift;;
            -h | --help )
                usage
                return
                shift ;;
            -- )
                shift
                break ;;
            * )
                break ;;
        esac
    done


    current_time() {
        echo $(($(date +%s%N)/1000000))
    }

    show_test_duration() {
        TIME_LAST_TEST=$1
        CURRENT_TIME=`current_time`
        DURATION=$((CURRENT_TIME-TIME_LAST_TEST))
        printf "(%5dms) " "$DURATION"
    }

    clear_line() {
        printf "\r%b" "\033[2K"
    }

    filter_output() {
        GREEN="1;32"
        YELLOW="1;33"
        GREP="egrep --color=always"

        START_TIME=`current_time`
        TIME_LAST_TEST=$START_TIME
        TESTS_TOTAL=0
        TESTS_FAILED=0
        TESTS_SKIPPED=0
        TESTS_PASSED=0

        while read data; do
            clear_line
            case "$data" in
                *\#\ TODO\ \(unimplemented\)? )
                    TESTS_SKIPPED=$((TESTS_SKIPPED+1))
                    if $IS_VERBOSE; then
                        show_test_duration $TIME_LAST_TEST
                        TIME_LAST_TEST=$CURRENT_TIME
                    fi
                    echo "$data" | GREP_COLORS="ms=$YELLOW" $GREP "\b(^ok [0-9]+)\b|"
                    ;;
                ok\ [0-9]* )
                    TESTS_PASSED=$((TESTS_PASSED+1))
                    if $IS_VERBOSE; then
                        show_test_duration $TIME_LAST_TEST
                        TIME_LAST_TEST=$CURRENT_TIME
                        echo "$data" | GREP_COLORS="ms=$GREEN" $GREP "\b(^ok [0-9]+)\b|"
                    fi
                    ;;
                not\ ok\ [0-9]* )
                    TESTS_FAILED=$((TESTS_FAILED+1))
                    if $IS_VERBOSE; then
                        show_test_duration $TIME_LAST_TEST
                        TIME_LAST_TEST=$CURRENT_TIME
                    fi
                    echo -e "\e[1;31m$data\e[0m"
                    ;;
                \#\ Looks\ like\ you* )
                    ;;
                \#\ * )
                    if $IS_VERBOSE; then
                        printf "%10s"
                    fi
                    echo "$data" | GREP_COLORS="ms=$YELLOW" $GREP "^# |"
                    ;;
                1..[0-9]* )
                    ;;
                * )
                    if $IS_VERBOSE; then
                        printf "%10s"
                    fi
                    echo -e "\033[1m$data\033[0m"
                    ;;
            esac

            TESTS_TOTAL=$((TESTS_PASSED+TESTS_FAILED+TESTS_SKIPPED))
            END_TIME=`current_time`
            ELAPSED_TIME=$((($END_TIME - $START_TIME)/1000))
            printf "\033[1mTests: %5d,     time: %ds\033[0m" "$TESTS_TOTAL" "$ELAPSED_TIME"
        done
        clear_line

        END_TIME=`current_time`
        ELAPSED_SECONDS=$((($END_TIME - $START_TIME)/1000))
        ELAPSED_MILLISECONDS=$((($END_TIME - $START_TIME)%1000))

        if [ $TESTS_FAILED -ne 0 ]; then
            RESULT_FAILED=`printf "\e[1;31m%d failed\e[0m, " "$TESTS_FAILED"`
        fi
        if [ $TESTS_PASSED -ne 0 ]; then
            RESULT_PASSED=`printf "\e[1;32m%d passed\e[0m, " "$TESTS_PASSED"`
        fi
        if [ $TESTS_SKIPPED -ne 0 ]; then
            RESULT_SKIPPED=`printf "\e[1;33m%d skipped\e[0m, " "$TESTS_SKIPPED"`
        fi

        printf "\nTests:    %s%s%s%d total\n" \
            "$RESULT_FAILED" "$RESULT_SKIPPED" "$RESULT_PASSED" "$TESTS_TOTAL"
        printf "Time:     %d.%03ds\n" "$ELAPSED_SECONDS" "$ELAPSED_MILLISECONDS"
        printf "\e[2;37mRan all tests.\e[0m\n\n"
    }

    run_tests() {
        $CLEAR
        docker run -it --rm \
            -v "$PWD":/usr/working \
            -w /usr/working $DOCKER_IMAGE \
            perl backend-tests/test.pl \
            | filter_output


    }

    if $IS_DOCKER_IMAGE_PULLED; then
        docker pull $DOCKER_IMAGE
    fi

    WATCH_PATH=`pwd`
    TEMP_FILE=`mktemp --suffix -qwiki-watcher`

    if $IS_WATCHED; then
        while true; do
            run_tests
            find $WATCH_PATH -name '*.pm' -o -name '*.pl' -o -name '*.po' > $TEMP_FILE
            inotifywait -e CLOSE_WRITE --fromfile $TEMP_FILE
        done
    else
        run_tests
    fi
}
